{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:11:20.667998Z",
     "start_time": "2021-03-20T18:11:19.679890Z"
    }
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import torch.nn.functional as F\n",
    "import torchvision\n",
    "from torchvision import transforms\n",
    "\n",
    "import time\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:11:20.809456Z",
     "start_time": "2021-03-20T18:11:20.777527Z"
    }
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\nenec\\anaconda3\\lib\\site-packages\\torch\\cuda\\__init__.py:52: UserWarning: CUDA initialization: Found no NVIDIA driver on your system. Please check that you have an NVIDIA GPU and installed a driver from http://www.nvidia.com/Download/index.aspx (Triggered internally at  ..\\c10\\cuda\\CUDAFunctions.cpp:100.)\n",
      "  return torch._C._cuda_getDeviceCount() > 0\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "device(type='cpu')"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "device"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:11:23.855076Z",
     "start_time": "2021-03-20T18:11:23.840119Z"
    }
   },
   "outputs": [],
   "source": [
    "class Network(nn.Module):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        self.conv1 = nn.Conv2d(in_channels=1, out_channels=6, kernel_size=5) #kernel = filter size. #out = number of filters\n",
    "        self.conv2 = nn.Conv2d(in_channels=6, out_channels=12, kernel_size=5)\n",
    "\n",
    "        self.fc1 = nn.Linear(in_features=12 * 4 * 4, out_features=120)\n",
    "        self.fc2 = nn.Linear(in_features=120, out_features=60)\n",
    "        self.out = nn.Linear(in_features=60, out_features=10)\n",
    "      \n",
    "    \n",
    "    def forward(self, t):   \n",
    "    #hidden conv layers\n",
    "        t = self.conv1(t) \n",
    "        t = F.relu(t) #activation function\n",
    "        t = F.max_pool2d(t, kernel_size=2, stride=2)\n",
    "    \n",
    "        t = self.conv2(t)\n",
    "        t = F.relu(t)\n",
    "        t = F.max_pool2d(t, kernel_size=2, stride=2)\n",
    "    \n",
    "    #hidden linear layers.\n",
    "        t = t.reshape(-1, 12*4*4)\n",
    "        t = self.fc1(t)\n",
    "        t = F.relu(t)\n",
    "    \n",
    "        t = self.fc2(t)\n",
    "        t = F.relu(t)\n",
    "    \n",
    "    #output layer\n",
    "        t = self.out(t)\n",
    "  \n",
    "        return t"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:11:26.714186Z",
     "start_time": "2021-03-20T18:11:26.699226Z"
    }
   },
   "outputs": [],
   "source": [
    "USPS_transform = transforms.Compose([\n",
    "    transforms.Resize((28, 28)),\n",
    "    transforms.ToTensor(),\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:11:32.324635Z",
     "start_time": "2021-03-20T18:11:30.412674Z"
    }
   },
   "outputs": [],
   "source": [
    "mnist = torchvision.datasets.MNIST(\"\"\n",
    "                       , train=True\n",
    "                       , download=True\n",
    "                       , transform = transforms.Compose([transforms.ToTensor()])\n",
    "                        )\n",
    "\n",
    "usps = torchvision.datasets.USPS(\"./data\"\n",
    "                     , train=True\n",
    "                     , download=True\n",
    "                     , transform = USPS_transform\n",
    "                    )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:11:32.340311Z",
     "start_time": "2021-03-20T18:11:32.326964Z"
    }
   },
   "outputs": [],
   "source": [
    "def get_num_correct(preds, labels): \n",
    "    return preds.argmax(dim=1).eq(labels).sum().item()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:05.727566Z",
     "start_time": "2021-03-20T18:12:05.710611Z"
    }
   },
   "outputs": [],
   "source": [
    "#As a first test, let's make a prediction on an untrained network. It's expected to have e low accuracy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:15.057309Z",
     "start_time": "2021-03-20T18:12:15.041352Z"
    }
   },
   "outputs": [],
   "source": [
    "mnist_loader = torch.utils.data.DataLoader(mnist, batch_size = 100, shuffle=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:18.984713Z",
     "start_time": "2021-03-20T18:12:18.956789Z"
    }
   },
   "outputs": [],
   "source": [
    "network = Network()\n",
    "batch = next(iter(mnist_loader))\n",
    "images, labels = batch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:23.035293Z",
     "start_time": "2021-03-20T18:12:23.025319Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "torch.Size([100, 1, 28, 28])"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "images.shape #A batch is made of 100 imagines, with 1 channel color (grayscale), dim: 28x28"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:28.542613Z",
     "start_time": "2021-03-20T18:12:28.520674Z"
    }
   },
   "outputs": [],
   "source": [
    "preds = network(images) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:31.884549Z",
     "start_time": "2021-03-20T18:12:31.872580Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n",
       "        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n",
       "        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n",
       "        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n",
       "        5, 5, 5, 5])"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "preds.argmax(dim=1) #Values predicted by the network"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:42.156973Z",
     "start_time": "2021-03-20T18:12:42.145006Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([0, 7, 1, 3, 3, 5, 9, 6, 3, 5, 4, 1, 3, 1, 9, 0, 0, 3, 7, 9, 5, 5, 4, 3,\n",
       "        6, 3, 6, 7, 4, 5, 0, 5, 0, 5, 4, 8, 4, 7, 1, 6, 0, 9, 8, 3, 0, 4, 6, 1,\n",
       "        1, 5, 2, 3, 5, 4, 8, 2, 6, 2, 0, 1, 7, 6, 8, 2, 2, 0, 4, 8, 2, 4, 4, 9,\n",
       "        4, 7, 2, 5, 6, 2, 8, 0, 0, 1, 9, 4, 9, 6, 6, 0, 4, 9, 5, 4, 1, 7, 3, 1,\n",
       "        4, 3, 0, 2])"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "labels #The true values of the batch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:12:45.631770Z",
     "start_time": "2021-03-20T18:12:45.621798Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "11"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_num_correct(preds, labels) #The number of correct prediction is very low (around 10% because it guesses at random!)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:13:08.013488Z",
     "start_time": "2021-03-20T18:13:07.999525Z"
    }
   },
   "outputs": [],
   "source": [
    "#NOW LET'S TRAIN OUR NETWORK ON MNIST. THE WEIGHTS AND BIASES ARE AT FIRST RANDOMIZED, BUT WITH EACH EPOCH WE LOOK FOR THE\n",
    "#MINIMUM GRADIENT AND THUS MINIMIZE THE LOSS. THE OPTIMIZER TELLS US THE STEP OF THE LEARNING RATE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:13:09.982619Z",
     "start_time": "2021-03-20T18:13:09.975591Z"
    }
   },
   "outputs": [],
   "source": [
    "def training(network, loader, optimizer, num_epochs):\n",
    "    for epoch in range(num_epochs):\n",
    "\n",
    "        total_loss = 0\n",
    "        total_correct = 0\n",
    "\n",
    "        for batch in loader:\n",
    "            images, labels = batch\n",
    "    \n",
    "            preds = network(images)\n",
    "            loss = F.cross_entropy(preds, labels)\n",
    "    \n",
    "            optimizer.zero_grad() #gradient must be reset every time, otherwise it's added to the previous one\n",
    "            loss.backward()\n",
    "            optimizer.step()\n",
    "    \n",
    "            total_loss += loss.item()\n",
    "            total_correct += get_num_correct(preds, labels)\n",
    "    \n",
    "        print(\"epoch:\", epoch, \"total_correct:\", total_correct, \"loss:\", total_loss)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:13:15.774049Z",
     "start_time": "2021-03-20T18:13:15.760098Z"
    }
   },
   "outputs": [],
   "source": [
    "optimizer = optim.Adam(network.parameters(), lr=0.01)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:13:22.079866Z",
     "start_time": "2021-03-20T18:13:22.075877Z"
    }
   },
   "outputs": [],
   "source": [
    "mnist_training = torch.utils.data.DataLoader(mnist, batch_size = 100, shuffle=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:15:54.020673Z",
     "start_time": "2021-03-20T18:13:26.360772Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch: 0 total_correct: 56125 loss: 119.47598038613796\n",
      "epoch: 1 total_correct: 58670 loss: 44.37592809018679\n",
      "epoch: 2 total_correct: 58829 loss: 41.7818964861799\n",
      "epoch: 3 total_correct: 58935 loss: 37.628778530459385\n",
      "epoch: 4 total_correct: 58995 loss: 36.39221311121946\n",
      "epoch: 5 total_correct: 59064 loss: 35.19196750456467\n",
      "epoch: 6 total_correct: 59031 loss: 34.6643854441063\n",
      "epoch: 7 total_correct: 59148 loss: 32.8998802305141\n",
      "epoch: 8 total_correct: 59068 loss: 34.656969150179066\n",
      "epoch: 9 total_correct: 59137 loss: 33.45586334816471\n"
     ]
    }
   ],
   "source": [
    "training(network, mnist_training, optimizer, 10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:06.015051Z",
     "start_time": "2021-03-20T18:16:05.995064Z"
    }
   },
   "outputs": [],
   "source": [
    "#Look at the loss reduction! Now the network is trained on mnist and expected to predict very well"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:27.190773Z",
     "start_time": "2021-03-20T18:16:27.184789Z"
    }
   },
   "outputs": [],
   "source": [
    "mnist_test_loader = torch.utils.data.DataLoader(mnist, batch_size = 100, shuffle=True)\n",
    "#Let's take another loader for the sake of shuffling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:30.592504Z",
     "start_time": "2021-03-20T18:16:30.560614Z"
    }
   },
   "outputs": [],
   "source": [
    "mnist_test = next(iter(mnist_test_loader))\n",
    "images_test, labels_test = mnist_test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:35.419506Z",
     "start_time": "2021-03-20T18:16:35.395529Z"
    }
   },
   "outputs": [],
   "source": [
    "preds_test = network(images_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:36.732215Z",
     "start_time": "2021-03-20T18:16:36.720248Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([5, 3, 2, 8, 9, 2, 4, 7, 0, 0, 4, 6, 2, 9, 1, 0, 5, 8, 3, 3, 7, 5, 4, 4,\n",
       "        0, 1, 8, 3, 6, 4, 2, 5, 0, 5, 3, 2, 5, 9, 5, 9, 7, 5, 8, 5, 2, 5, 0, 3,\n",
       "        9, 3, 4, 2, 6, 3, 8, 9, 8, 8, 6, 8, 0, 7, 2, 2, 2, 9, 1, 0, 5, 8, 3, 0,\n",
       "        8, 1, 9, 3, 6, 4, 1, 1, 7, 9, 9, 7, 3, 6, 1, 1, 5, 3, 6, 3, 8, 4, 3, 0,\n",
       "        1, 0, 1, 2])"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "labels_test #The true values of the batch we are considering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:40.825910Z",
     "start_time": "2021-03-20T18:16:40.811910Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([5, 3, 2, 8, 9, 2, 4, 7, 0, 0, 4, 6, 2, 9, 1, 0, 5, 8, 3, 3, 7, 5, 4, 4,\n",
       "        0, 1, 8, 3, 6, 4, 2, 5, 0, 5, 3, 2, 5, 9, 5, 9, 7, 5, 8, 5, 2, 5, 0, 3,\n",
       "        9, 3, 4, 2, 6, 3, 8, 9, 8, 8, 6, 8, 0, 7, 2, 2, 2, 9, 1, 0, 5, 8, 3, 0,\n",
       "        8, 1, 9, 3, 6, 4, 1, 1, 7, 9, 9, 7, 3, 6, 1, 1, 5, 3, 6, 3, 8, 4, 3, 0,\n",
       "        1, 0, 1, 2])"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "preds_test.argmax(dim=1) #Predicted values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:43.966679Z",
     "start_time": "2021-03-20T18:16:43.945735Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "100"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_num_correct(preds_test, labels_test) #Wow! Now the network is predicting really well!!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:57.415618Z",
     "start_time": "2021-03-20T18:16:57.398664Z"
    }
   },
   "outputs": [],
   "source": [
    "### What happens now if I add USPS? ###"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:16:58.923398Z",
     "start_time": "2021-03-20T18:16:58.920413Z"
    }
   },
   "outputs": [],
   "source": [
    "#If I make the network make a prediction on a batch from the USPS, this will predict badly because the weights and bias\n",
    "#are not appropiate for it"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:17:16.615977Z",
     "start_time": "2021-03-20T18:17:16.608996Z"
    }
   },
   "outputs": [],
   "source": [
    "usps_pretest_loader = torch.utils.data.DataLoader(usps, batch_size = 100, shuffle=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:18:14.004214Z",
     "start_time": "2021-03-20T18:18:13.980279Z"
    }
   },
   "outputs": [],
   "source": [
    "usps_pretest = next(iter(usps_pretest_loader))\n",
    "usps_images_test, usps_labels_test = usps_pretest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:18:43.662548Z",
     "start_time": "2021-03-20T18:18:43.639609Z"
    }
   },
   "outputs": [],
   "source": [
    "usps_preds_pretest = network(usps_images_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:19:09.160215Z",
     "start_time": "2021-03-20T18:19:09.152236Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([5, 1, 6, 9, 7, 9, 4, 6, 5, 9, 8, 9, 6, 9, 9, 7, 0, 0, 6, 6, 3, 5, 1, 0,\n",
       "        5, 4, 9, 6, 1, 4, 6, 9, 4, 3, 0, 0, 4, 7, 4, 3, 0, 8, 8, 1, 1, 6, 8, 2,\n",
       "        4, 1, 0, 1, 2, 3, 6, 9, 7, 4, 5, 1, 7, 1, 2, 5, 1, 1, 3, 3, 7, 5, 7, 7,\n",
       "        0, 5, 8, 2, 6, 2, 4, 3, 0, 2, 3, 9, 4, 0, 7, 8, 8, 6, 4, 7, 6, 0, 2, 2,\n",
       "        0, 9, 1, 0])"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "usps_labels_test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:19:52.995324Z",
     "start_time": "2021-03-20T18:19:52.977372Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n",
       "        1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n",
       "        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 8, 1, 1,\n",
       "        1, 7, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n",
       "        1, 1, 1, 1])"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "usps_preds_pretest.argmax(dim=1) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:20:34.873330Z",
     "start_time": "2021-03-20T18:20:34.860365Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "15"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_num_correct(usps_preds_pretest, usps_labels_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:21:01.129491Z",
     "start_time": "2021-03-20T18:21:01.122556Z"
    }
   },
   "outputs": [],
   "source": [
    "#As expected! Our network guesses again only about 10%, because it is not trained on the usps"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:22:24.745490Z",
     "start_time": "2021-03-20T18:22:06.977295Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch: 0 total_correct: 6437 loss: 30.997983515262604\n",
      "epoch: 1 total_correct: 7011 loss: 10.111000021919608\n",
      "epoch: 2 total_correct: 7092 loss: 6.654686199501157\n",
      "epoch: 3 total_correct: 7166 loss: 4.534430328756571\n",
      "epoch: 4 total_correct: 7190 loss: 3.3648469148902223\n",
      "epoch: 5 total_correct: 7209 loss: 2.930035855155438\n",
      "epoch: 6 total_correct: 7198 loss: 3.0244248950621113\n",
      "epoch: 7 total_correct: 7202 loss: 4.096723569207825\n",
      "epoch: 8 total_correct: 7232 loss: 1.9913759651244618\n",
      "epoch: 9 total_correct: 7255 loss: 1.1355954440368805\n"
     ]
    }
   ],
   "source": [
    "#Let's train the same network on the USPS, using the same optimizer with the same learning rate\n",
    "training(network, usps_pretest_loader, optimizer, 10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:22:51.563751Z",
     "start_time": "2021-03-20T18:22:51.557767Z"
    }
   },
   "outputs": [],
   "source": [
    "### question: WHY IS THE EXECUTION TIME SO QUICK WITH RESPECT TO THE TRAINING ON THE MNIST? WHY IS THE LOSS SO LOW? ###"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:23:22.304615Z",
     "start_time": "2021-03-20T18:23:22.288674Z"
    }
   },
   "outputs": [],
   "source": [
    "#Let's see now if it's predicting better on the usps"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:23:50.014488Z",
     "start_time": "2021-03-20T18:23:50.008504Z"
    }
   },
   "outputs": [],
   "source": [
    "usps_posttraining_loader = torch.utils.data.DataLoader(usps, batch_size = 100, shuffle=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:25:02.389235Z",
     "start_time": "2021-03-20T18:25:02.366296Z"
    }
   },
   "outputs": [],
   "source": [
    "usps_posttraining = next(iter(usps_posttraining_loader))\n",
    "usps_images_post, usps_labels_post = usps_posttraining"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:25:38.614797Z",
     "start_time": "2021-03-20T18:25:38.591860Z"
    }
   },
   "outputs": [],
   "source": [
    "usps_preds_posttraining = network(usps_images_post)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:26:04.527943Z",
     "start_time": "2021-03-20T18:26:04.514978Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([3, 2, 3, 8, 0, 7, 0, 0, 0, 4, 9, 8, 5, 7, 9, 0, 0, 7, 4, 9, 1, 9, 7, 8,\n",
       "        0, 5, 4, 0, 2, 0, 2, 4, 7, 1, 2, 9, 7, 0, 4, 3, 2, 3, 6, 1, 4, 1, 0, 5,\n",
       "        1, 2, 0, 9, 4, 1, 6, 7, 9, 3, 4, 8, 8, 0, 1, 0, 4, 0, 4, 7, 2, 4, 2, 2,\n",
       "        2, 9, 1, 2, 1, 4, 8, 7, 9, 1, 9, 5, 3, 1, 2, 6, 2, 8, 9, 9, 3, 7, 0, 7,\n",
       "        1, 9, 3, 0])"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "usps_labels_post"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:26:26.857890Z",
     "start_time": "2021-03-20T18:26:26.837941Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([3, 2, 3, 8, 0, 7, 0, 0, 0, 4, 9, 8, 5, 7, 9, 0, 0, 7, 4, 9, 1, 4, 7, 8,\n",
       "        0, 5, 4, 0, 2, 0, 2, 4, 7, 1, 2, 9, 7, 0, 4, 3, 2, 3, 6, 1, 4, 1, 0, 5,\n",
       "        1, 2, 0, 9, 4, 1, 6, 7, 9, 3, 4, 8, 8, 0, 1, 0, 4, 0, 4, 7, 2, 4, 2, 2,\n",
       "        2, 9, 1, 2, 1, 4, 8, 7, 9, 1, 9, 5, 3, 1, 2, 6, 2, 8, 9, 9, 3, 7, 0, 7,\n",
       "        1, 9, 3, 0])"
      ]
     },
     "execution_count": 45,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "usps_preds_posttraining.argmax(dim=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:26:59.776359Z",
     "start_time": "2021-03-20T18:26:59.765347Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "99"
      ]
     },
     "execution_count": 46,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_num_correct(usps_preds_posttraining, usps_labels_post)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T18:27:39.709371Z",
     "start_time": "2021-03-20T18:27:39.704340Z"
    }
   },
   "outputs": [],
   "source": [
    "#YES!!! But will the network remember the MNIST now?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T19:00:53.707262Z",
     "start_time": "2021-03-20T19:00:53.660292Z"
    }
   },
   "outputs": [],
   "source": [
    "mnist_post_loader = torch.utils.data.DataLoader(mnist, batch_size = 100, shuffle=True)\n",
    "mnist_test_post = next(iter(mnist_post_loader))\n",
    "mnist_images_post, mnist_labels_post = mnist_test_post"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T19:00:56.990405Z",
     "start_time": "2021-03-20T19:00:56.967672Z"
    }
   },
   "outputs": [],
   "source": [
    "mnist_preds_post = network(mnist_images_post)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T19:01:00.475002Z",
     "start_time": "2021-03-20T19:01:00.458579Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([6, 0, 1, 1, 6, 7, 3, 1, 1, 1, 2, 6, 5, 8, 0, 0, 8, 2, 2, 1, 5, 6, 8, 3,\n",
       "        1, 7, 9, 7, 8, 2, 3, 9, 1, 1, 8, 8, 7, 9, 4, 6, 0, 1, 9, 0, 0, 4, 9, 5,\n",
       "        4, 4, 4, 1, 1, 4, 9, 7, 2, 0, 6, 6, 2, 5, 0, 8, 8, 1, 2, 5, 7, 0, 5, 4,\n",
       "        7, 7, 3, 0, 0, 2, 2, 0, 6, 3, 9, 1, 5, 0, 6, 0, 7, 7, 6, 5, 2, 6, 5, 4,\n",
       "        1, 1, 8, 0])"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "mnist_labels_post"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T19:01:03.987404Z",
     "start_time": "2021-03-20T19:01:03.974725Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([5, 0, 1, 1, 6, 4, 3, 2, 1, 1, 2, 6, 5, 8, 7, 0, 8, 2, 2, 1, 5, 6, 8, 3,\n",
       "        6, 9, 9, 8, 8, 2, 3, 9, 6, 1, 8, 8, 9, 9, 4, 6, 0, 1, 9, 0, 0, 4, 9, 5,\n",
       "        4, 4, 4, 1, 1, 4, 9, 7, 2, 0, 6, 6, 2, 5, 0, 8, 8, 1, 2, 5, 9, 0, 5, 4,\n",
       "        5, 9, 3, 0, 0, 2, 2, 0, 6, 3, 9, 1, 5, 0, 6, 0, 3, 5, 6, 5, 2, 6, 8, 9,\n",
       "        6, 1, 8, 0])"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "mnist_preds_post.argmax(dim=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-03-20T19:01:45.317678Z",
     "start_time": "2021-03-20T19:01:45.293127Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "83"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_num_correct(mnist_preds_post, mnist_labels_post)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# THE PREDICTION ON WORSE THAN BEFORE USING USPS BUT IT'S STILL PRETTY HIGH.##\n",
    "## THIS IS WHERE I WOULD START USING EWC TO HANDLE THIS CATASTROPHIC FORGETTING ##\n",
    "#my guess: mnist and usps are actually pretty similar, so the network can still be able to guess both. if we were to retrain\n",
    "#the network on something much different (randomly permuted mnist) it would act much worse\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
